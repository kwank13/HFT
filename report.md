#High-Frequency Foreign Exchange Currency Trading (Forex HFT)

###Spring 2016

####Members: Graham Gobieski, Kevin Kwan, Ziyi Zhu, Shang Liu
#####UNIs: gsg2120, kjk2150, zz2374, sl3881

===

##Table of Index
1. Abstract
2. Introduction
3. Design
  - 3.1 Overview
  - 3.2 Project Setup
	- 3.3 Hardware Architecture
	    - 3.3.1 Bellman-Ford Algorithm
	    - 3.3.2 Memory Access
	    - 3.3.3 VGA
	- 3.4 Software
	    - 3.4.1 Streaming to FPGA
	    - 3.4.2 Data Format
4. Conclusions
5. References
Appendix: Code

##1 Abstract
Our project goal is to create a High Frequency Trading (HFT) platform on an Altera Cyclone V SoCKit board that can detect arbitrage in the Foreign Exchange (FOREX) Market.  Simulated data is streamed to the FPGA and stored in on-chip memory.  The FPGA runs the Bellman-Ford algorithm and checks for arbitrage opportunities represented by a negative weight cycle.  

##2 Introduction
High frequency trading is a trading platform that uses computer algorithms and powerful technology tools to perform a large number of trades at very high speeds. Initially, HFT firms operated on a time scale of seconds, but as technology has improved, so has the time required to execute a trade. Firms now compete at the milli- or even microsecond level. This has led to many firms turning to field programmable gate arrays (FPGAs) to achieve greater performance.

Our project focuses on triangular arbitrage opportunities on the foreign exchange market (Forex). The Forex market is a decentralized marketplace for trading currency. All trading is conducted over the counter via computer networks between traders around the world. Unlike the stock market, the Forex market is open 24 hours for most of the week.

Currencies are priced in relation to each other and quoted in pairs that look like this: `EUR/USD 1.1837`. The currency on the left is the base currency and the one on the right is called the cross currency or quote. The base currency is always assumed to be one unit, and the quoted price is what the base currency is equal to in the other currency. In this example, `1 Euro = 1.1837 USD.`

Triangular arbitrage takes advantage of pricing inequalities across three or more different currencies to make a profit. In a three currency situation, one currency is exchanged for a second, the second for a third currency, and finally the third back to the original currency. For example, if the exchange rates for the following currency pairs were `EUR/USD 1.1837`, `EUR/GBP 0.7231`, and `GBP/USD 1.6388` a  trader could use 11,847 USD to buy 10,000 Euros.  Those Euros could be sold for 7231 British Pounds, which could then be sold for 11,850 USD, netting a profit of 13 USD. Unfortunately, acting on these price inefficiencies quickly corrects them, meaning traders must be ready to act immediately when an arbitrage opportunity occurs.

Our group hopes to implement a Forex arbitrage calculator on an FPGA using a parallelized Bellman-Ford algorithm. We believe this will be fast enough to detect and act on arbitrage opportunities in near real time.

##3. Design
###3.1 Overview
Our system 
###3.2 Project Setup
###3.3 Hardware Architecture
####3.3.1 Bellman-Ford Algorithm
####3.3.2 Memory
####3.3.3 VGA
To show the negative cycles (paths for exchanging currencies to make profits) clearly, we used the VGA module to generate numbers, indicating each currency within the cycle, in series on the screen. As shown in ****Fig. 1000**, when we press “enter” on the cycle we are choosing, each number will be translated into abbreviated characters to show the chain in a more readable way. Since we are calculating the currencies represented by indices in the Bellman Ford and Cycle detect calculation module, the results are those indices. It is easier for us to show those indices first on the screen and then convert into characters. For each index we have, we need to read it from the memory and translated into 2-digits number to show. Between each of these currencies, we also need an arrow to tell us the direction of the negative cycle, in other words, the way of exchanging currencies.
These numbers and characters are shown by 16x16 pixels on the screen and stored in one big Rom memory. Thus, we need 256 bits to store each of them with their own addresses in the memory and read them according to the numbers and characters needed to show on the screen. All of these numbers and characters are sprites, and we have total 38 sprites including: 26 capital characters, 10 digit numbers, 1 arrow and 1 totally black. Each sprite is first generated by mif file manually and then join them together into a big mif file. After the big mif file is generated, it can be used to create the memory we need via MegaWizard Plug-in Manager in Quartus II. The relevant code of reading memory is shown **as following*****:

####3.3.3.2 Keyboard
As mentioned before, when we press “enter” on the keyboard connected to the FPGA as peripheral, the cycle can be shown in a more readable way. This is supported by Usblib module, making communication between the peripheral (keyboard) and the FPGA. Four keys are defined “esc”, “enter”, “upshift” and “downshift”. When the software built in the arm processor receives those four keys, it will transmit corresponding data to the FPGA via Avalon Bus as what we did in lab3 and to indicate the operation shown on the screen. When in the cycle we find out, “enter” gives us the name of each currencies and shown in the middle of the screen. When we are in the “enter” state, only “esc” can be responded and exit to the state before the “enter” state, and we can choose the cycle via pressing “upshift” and “downshift” keys.

##4 Conclusions
###4.1 Results
We were able to successfully detect negative weight cycles with our project using test graphs that we created. We tested using graphs with up to seven nodes, but there is no reason to believe that there will be any problems scaling up to the full 66 nodes.
            <a couple pictures of different node graphs>

Our project is also able to detect multiple negative cycles within a graph.
                    <multi cycle pic>

This is important because we want to be able to see all arbitrage opportunities at a given moment, not just the cycle with the most negative weight.

We did test our project with some historical data we were able to find, but unfortunately were not able find any negative cycles

                <still from historical data test>

However, given our results from smaller tests, we believe it is more likely that the historical data we used simply did not have any arbitrage opportunities. Our initial research had said that these opportunities were fairly uncommon. In this case, the project should not show any output because there are no negative cycles.

Overall, we feel our results are promising. Our project can successfully detect multiple negative cycles within a graph and display the corresponding nodes that make up the cycle. We can also stream in historical data from the FOREX market and run it through the FPGA. We estimate the time our project takes to detect a negative cycle is roughly 20ms. This is only a little slower than actual HFT platforms and there is still room to tweak our hardware to get better performance.

###4.2 Lessons Learned
The main takeaway we had from this project was that timing diagrams are very important, especially with memory access. We had issues with our project that seemed impossible to solve until we used a tool to generate timing diagrams. Once we looked at those, it was easy to see where our project was out of sync. 

We also learned that memory is a major constraint on the FPGA. We initially thought that memory would be as simple as using one of the pre-made templates in Quartus.  However, properly writing and reading from memory quickly became our main focus.

###4.3 Future Goals
In the future we would like to be able to fully integrate our project to run on the live FOREX market. This would involve modifying our project to be able to receive live FOREX data and to be able to act on arbitrage opportunities when they arise.

Unfortunately, we did not have an opportunity to test with real data because real-time FOREX data is hard to get without paying for access to it. We instead opted to use historical data stored in a .csv file and stream it over to the FPGA.  To work in a live environment, we will have to modify our software to pull data directly from a live stream before sending it to the FPGA as opposed to reading from a file.  This should not be too difficult and most FOREX brokers provide APIs to do this. 

We also need to change our program to let it act on arbitrage opportunities. Currently we only output the appropriate currency cycle to the screen by using the hardware to send data over the VGA port. In addition to this, we also want our project to be able to send buy and sell requests to a trader. We would probably need to modify the FPGA to send cycle to the software via serial or USB.  The software could then interface with a trader’s API and make trades to take advantage of the arbitrage opportunity.

Our project performs fairly quickly, but there is still room for improvement.  We believe that we can still cut down on the amount of cycles our program needs to run, which will give a small boost in performance. More importantly, we can get greater speeds by parallelizing the Bellman-Ford algorithm. Although we initially based our project on a paper parallelizing Bellman-Ford on a FPGA, our own implementation ended up mostly serial.  A parallel Bellman-Ford algorithm would allow us to take greater advantage of running the project on a FPGA.
